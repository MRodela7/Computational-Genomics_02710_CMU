# -*- coding: utf-8 -*-
"""Compt Genomics Hw1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y_mfzX5DdZ6VRPDJJNQxdA7jKa4lcCRn
"""

# NW.py
# HW1, Computational Genomics, Spring 2022
# andrewid:

# WARNING: Do not change the file name; Autograder expects it.

import sys

import sys

matchScore= 1
mismatchScore=-2
gapPenalty=-1

import numpy as np

def ReadFASTA(filename):
    fp=open(filename, 'r')
    Sequences={}
    tmpname=""
    tmpseq=""
    for line in fp:
        if line[0]==">":
            if len(tmpseq)!=0:
                Sequences[tmpname]=tmpseq
            tmpname=line.strip().split()[0][1:]
            tmpseq=""
        else:
            tmpseq+=line.strip()
    Sequences[tmpname]=tmpseq
    fp.close()
    return Sequences


import numpy as np

def algo(seq1, seq2):
  #dynamic programming matrix
    m, n = len(seq1), len(seq2)
    D = [[0 for j in range(n+1)] for i in range(m+1)]

    # Initialize the first row and first column of the matrix
    for i in range(1, m+1):
        D[i][0] = D[i-1][0] + gapPenalty
    for j in range(1, n+1):
        D[0][j] = D[0][j-1] + gapPenalty
    
    #fill the matrix
    for i in range(1, m+1):
        for j in range(1, n+1):
          matchS = D[i-1][j-1] + (matchScore if seq1[i-1] == seq2[j-1] else mismatchScore)
          possibleGapUp = D[i-1][j] + gapPenalty
          possibleGapLeft = D[i][j-1] + gapPenalty
          score = max(matchS, possibleGapUp, possibleGapLeft)
          D[i][j] = score
    return np.array(D)


def needleman_wunsch(seq1, seq2):
  
  D = algo(seq1, seq2)
  
  alignA = ""
  alignB = ""
  m, n = D.shape
  m = m-1
  n = n-1
  i, j =m, n
    
  while i>0 and j>0:
    #print("I:", i, "J:", j)
    diag = D[i-1][j-1]
    left = D[i][j-1]
    up = D[i-1][j]
    val = max(diag, left, up)
    if D[i-1][j-1]+ matchScore == D[i][j] and seq1[i-1] == seq2[j-1]: 
      alignA += seq1[i-1]
      alignB += seq2[j-1]
      i -=1
      j -=1
    elif D[i-1][j-1]+ mismatchScore == D[i][j] and seq1[i-1] != seq2[j-1]: 
      alignA += seq1[i-1]
      alignB += seq2[j-1]
      i -=1
      j -=1

    elif D[i][j] == D[i-1][j] + gapPenalty:
      alignB += '-'
      alignA += seq1[i-1]
      i -=1
    else:
      alignA += "-"
      alignB += seq2[j-1]
      j -=1
    

  # Finish tracing up to the top left cell
  while i > 0:
      alignA += seq1[i-1]
      alignB += "-"
      i -= 1
  while j > 0:
      alignA += "-"
      alignB += seq2[j-1]
      j -= 1

  alignA = alignA[::-1]
  alignB = alignB[::-1]
  return D[m][n], alignA, alignB


#def needleman_wunsch(seq1, seq2):
#   alignA = ""
#   alignB = ""
#   D = algo(seq1, seq2)
#   m, n = D.shape
#   m = m-1
#   n = n-1
#   i, j =m, n
#   while (i >0 or j >0):
#       diag = D[i-1][j-1]
#       left = D[i][j-1]
#       up = D[i-1][j-1]
#       val = max(diag, left, up)
#       if val == diag: 
#         alignA += seq1[i-1]
#         alignB += seq2[j-1]
#         i -=1
#         j -=1
#       elif val == left:
#         alignA += "-"
#         alignB += seq2[j-1]
#         j -=1
#       else:
#           alignB += '-'
#           alignA += seq1[i-1]
#           i -=1

  
#   # Finish tracing up to the top left cell
#   while i > 0:
#       alignA += seq1[i-1]
#       alignB += "-"
#       i -= 1
#   while j > 0:
#       alignA += "-"
#       alignB += seq2[j-1]
#       j -= 1

#   alignA = alignA[::-1]
#   alignB = alignB[::-1]
#   return D[m][n], alignA, alignB
         

if __name__=="__main__":
    Sequences=ReadFASTA(sys.argv[1])
    assert len(Sequences.keys())==2, "fasta file contains more than 2 sequences."
    seq1=Sequences[list(Sequences.keys())[0]]
    seq2=Sequences[list(Sequences.keys())[1]]

    score, align1, align2 = needleman_wunsch(seq1, seq2)

    print('Score: ', score)
    print('Seq1: ', align1)
    print('Seq2: ', align2)

